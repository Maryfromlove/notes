# 2020-06-22 喝了两杯奶茶的一天

## 懒狗日常

- LOL-ARAM-NA：胜2负3，运势小凶。
- 睡觉前奖励折腾了一天的自己看看《大理寺日志》。
- 我被1368E耽误太久了，下次不能再在一个题上挂那么久了。
- 明天有div2。
- 我一天喝了两次奶茶，但是我两顿都在食堂吃（不过分吧？
- 明天想做leetcode了。（我标签页开开关关好几次就是没做，懒死了）
- 好像今天运势确实不行，早上大乱斗就初露端倪。

## 故障调查：PPPoE不能正常实现代理

这个内容可能有点敏感。

运行环境：win10（2020-6月刚更新）

问题描述：wifi能正常科上，但是拨号的不能。就很离奇。



而且我的故障可能是很多方面的综合问题，简单地说就是我的拨号网络配置没有设置好。

我大概从以下几个方面做了调试：

- 换了合适的dns服务器ip。（这个问题是ping不存在的网站给我回到localhost了）
- 设置拨号连接的名称为英文，以及一些自动代理的小设置。
- 手动在`internet属性`中给当前的拨号连接设置代理地址。（这个问题是由于v2好像不会自动给拨号的做配置）

然后折腾了一下午，http请求正常能上了。

但是ping还会超时，这点我还不知道是什么原因，但是本懒狗累了。

## [Codeforces Global Round 8](https://codeforces.com/contest/1368)

### [1368E - Ski Accidents](https://codeforces.com/contest/1368/problem/E)

题意就是给你一个有向无环图，保证每个图出度不超过2。求一个删点的方案，使得删完点之后，剩下的图没有长度大于等于2的路径。（删点也就带走了边）要求是删除的点数不能超过$\frac{4}{7} n$。

标解的做法我有点懵，但是他好像能证明那个$\frac{4}{7} n$。毕竟是2500的难题，早知道我还是不要不自量力了。我在后面看到一个比较讨巧的做法，[我参考的做法](https://codeforces.com/blog/entry/79027?#comment-645275)：

- 建反向图（每个点的入度数不超过2）。
- 从拓扑序排在后面的点（其实按照题目的顺序，就是从1-n）开始枚举；
- 每次检查这个点是否存在一条以这个点为起点的长度为2的路径。
  - 是的话就删除这点，加入答案，注意建图也要修改（我用了set偷懒）
  - 否则这个点是保留的。

这样做完就是答案了，ac的时候我感觉，还有点不可思议。

但是粗糙地想一下，其实有点动态规划的感觉，拓扑序保证了，枚举到点i的时候，i的后继构成的子图已经是最优状态。那么下面就是贪心去判断i加入会不会打破这个状态就可以了。

至于为什么会在数量上比较优，我是这样理解的。

每个点最多两个入度，所以看起来，最坏情况是，每个留下的点，都有两个前驱被删掉了，$\frac{2}{3} n$。

但其实，如果有一个保留的点，两个前驱都被删掉，那么这个保留的点必有一个保留的后继点。（不然根据上面的算法，这两个前驱就不该删）。

再想想其他情形也不会超过，最坏的$\frac{1}{2} n$。这样足够说服我自己了。

```cpp
void solve(int kaseId = -1) {

    int n, m;
    cin >> n >> m;
    vint ans;
    vector<set<int>> des(n + 1);
    vector<set<int>> pre(n + 1);
    vint in(n + 1, 0), ut(n + 1, 0);


    for (int i = 1, u, v; i <= m; ++i) {
        cin >> v >> u;
        des[u].insert(v);
        pre[v].insert(u);
        in[v]++;
        ut[u]++;
    }

    for (int i = 1; i <= n; ++i) {
        bool check = false;
        for (auto d : des[i]) {
            if (!des[d].empty()) {
                check = true;
                break;
            }
        }
        if (check) {
            ans.emplace_back(i);
            for (auto p : pre[i]) des[p].erase(i);
            for (auto d : des[i]) pre[d].erase(i);
        }
    }

    cout << ans.size() << endl;
    for (auto ai:ans) {
        cout << ai << " ";
    }
    cout << endl;
}
```

我觉得和出题人心意相通是挺难的，能在有限时间里想到能自洽，且有一定道理的做法就够了。

我还想了一晚上，贼自闭。

**UDP:**

>🌎 1:11:48
>不过的确4/7是极限了
>
>🌎 1:11:55
>不可能比那个还小
>
>伍玖 1:12:10
>我不太会4/7的证明
>
>伍玖 1:12:27
>但是我感觉上是1/2的权重比较大
>
>🌎 1:12:30
>就最坏情况是一个三层的二叉树
>
>🌎 1:12:39
>或者6层之类的
>
>🌎 1:12:59
>你这样做会删掉最多节点的那层 就是4个 然后总共有7个
>
>伍玖 1:13:20
>emmm确实
>
>伍玖 1:13:23
>因为
>
>伍玖 1:13:34
>第二个样例就是这样

